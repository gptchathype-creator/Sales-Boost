# Проверка голосовых звонков после деплоя на Railway

Пошаговый алгоритм, чтобы убедиться, что звонки с диалогом и WebSocket работают на проде.

---

## Шаг 1. Дождаться успешного деплоя

1. Откройте [Railway Dashboard](https://railway.app) → ваш проект Sales-Boost.
2. Убедитесь, что деплой завершён (зелёный статус, без ошибок сборки/старта).
3. Запомните **публичный URL** приложения (например `https://sales-boost-production-xxxx.up.railway.app`). Он нужен дальше.

---

## Шаг 2. Переменные окружения на Railway

1. В проекте Railway откройте вкладку **Variables**.
2. Проверьте/добавьте:

| Переменная | Значение | Зачем |
|------------|----------|--------|
| `MINI_APP_URL` | Ваш URL Railway (из шага 1), без слеша в конце | Уже должно быть для Mini App. |
| `VOICE_DIALOG_BASE_URL` | **Тот же URL** Railway, без слеша в конце | Чтобы Voximplant ходил на ваш сервер за ответами нейронки. Пример: `https://sales-boost-production-xxxx.up.railway.app` |
| `VOICE_USE_STREAM` | `true` | Чтобы в сценарий передавался `stream_url` и использовался WebSocket (минимальная задержка). Если не задать или `false` — будет только POST. |

3. Сохраните переменные. Если что-то меняли — Railway перезапустит приложение.

---

## Шаг 3. Сценарий в Voximplant

1. Откройте [Voximplant Application Manager](https://manage.voximplant.com/) → ваше приложение → **Scenarios**.
2. Откройте сценарий **voice_dialog** (тот, что привязан к правилу `voice_dialog_rule`).
3. Убедитесь, что в нём **актуальный код** из репозитория: файл `voximplant/scenario_voice_dialog.js` (весь файл целиком).
4. Сохраните, если что-то меняли.

---

## Шаг 4. Как запустить тестовый звонок

Звонок с диалогом можно инициировать одним из способов.

### Вариант A: Локально (call-test сервер указывает на Railway)

1. На своём компьютере в **.env** в корне проекта задайте:
   ```env
   VOICE_DIALOG_BASE_URL=https://ВАШ-URL-RAILWAY.up.railway.app
   VOICE_USE_STREAM=true
   ```
   (подставьте реальный URL из шага 1, без слеша в конце).

2. Запустите сервер звонков:
   ```bash
   npm run call-test:dev
   ```

3. В другом терминале отправьте запрос:
   ```bash
   curl -X POST http://localhost:3001/call \
     -H "Content-Type: application/json" \
     -d '{"dialog": true}'
   ```
   Должен вернуться JSON с `call_id`. На номер из `VOX_TEST_TO` в .env придёт звонок.

### Вариант B: Из бота/админки на сервере

Если у вас на Railway или в боте есть кнопка/команда «Позвонить» или «Тестовый звонок», которая вызывает API Voximplant (StartScenarios) с `dialog: true` и передаёт `dialog_url`/`stream_url` — используйте её. Убедитесь, что сервер при инициации звонка подставляет в customData URL именно вашего приложения на Railway (тот же, что в `VOICE_DIALOG_BASE_URL`).

---

## Шаг 5. Проверка в трубке

1. Ответьте на входящий звонок.
2. Должно прозвучать **приветствие от нейронки** (первая реплика по сценарию).
3. Скажите что-нибудь (например «алло» или вопрос по объявлению) — должен прийти **ответ нейронки** и озвучиться.
4. Если приветствие есть и диалог идёт — базовая работоспособность подтверждена.

---

## Шаг 6. Проверка WebSocket по логам Railway

Чтобы убедиться, что используется именно WebSocket (а не только POST):

1. Railway Dashboard → ваш сервис → вкладка **Deployments** → откройте последний деплой → **View Logs** (или вкладка **Logs** у сервиса).
2. Инициируйте ещё один тестовый звонок (как в шаге 4) и сразу откройте логи.
3. В логах во время звонка должны появиться строки:
   - `[voice/stream] Client connected` — к вашему серверу подключился WebSocket-клиент (Voximplant).
   - `[voice/stream] Message received, length: ...` — получено сообщение с `call_id`.
   - `[voice/stream] call_id= ... text= (first)` — первый запрос (приветствие).
   - `[voice/stream] Sending N chunks` — сервер отправил чанки по WebSocket.

Если эти строки есть — WebSocket работает, задержка минимальная. Если их нет, но приветствие в трубке есть — сценарий отработал по fallback на POST (тоже нормально, но задержка может быть больше).

Дополнительно можно смотреть логи с тегом `[voice/dialog]` — они появляются при запросах по POST (первый и последующие реплики, если идут через POST).

---

## Шаг 7. Проверка логов Voximplant (по желанию)

1. В Voximplant откройте **Logs** и найдите сессию по вашему тестовому звонку (по времени или по `call_id` из ответа на запрос в шаге 4).
2. В логе сессии ожидаемо:
   - `WebSocket.Open` — соединение по стриму установлено.
   - Далее события `CreatePlayer` / `Player.PlaybackReady` и т.д. — воспроизведение приветствия.
   - `ASR.Started` / `ASR.Result` — распознавание вашей речи и отправка текста на бэкенд.
   - Снова `CreatePlayer` и т.д. — ответ нейронки.

Если видите `voice stream: no reply in 12s, fallback to POST` — по WebSocket ответ не пришёл, сценарий ушёл в POST; при этом приветствие всё равно должно было прозвучать после fallback.

---

## Краткий чеклист

- [ ] Деплой на Railway успешен.
- [ ] В Variables заданы `VOICE_DIALOG_BASE_URL` (URL Railway) и при необходимости `VOICE_USE_STREAM=true`.
- [ ] В Voximplant в сценарии voice_dialog вставлен актуальный код из репозитория.
- [ ] Тестовый звонок инициирован (локальный call-test с .env на Railway URL или кнопка в боте).
- [ ] В трубке звучит приветствие и идёт диалог.
- [ ] В логах Railway есть `[voice/stream] Client connected` и `[voice/stream] Message received` (подтверждение работы WebSocket).

Если на каком-то шаге что-то не так — проверьте URL (без слеша в конце), правильность правила и сценария в Voximplant и наличие переменных в Railway после перезапуска.
